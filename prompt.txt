Code completion task:

Complete the given partial Systemverilog RTL code based on the specification ./docs/Specification.md. The RTL code should be synthesizable.

PRBS15 generation:

The PRBS15 generator implements a linear feedback shift register (LFSR) to produce pseudo-random binary sequences using the polynomial x^15 + x^14 + 1. The generator produces an 8-bit parallel output on each clock cycle when enabled. The generator uses a 15-bit LFSR (bits [14:0]) with feedback computed as bit[14] XOR bit[13]. 

First, the seed will be loaded by toggling the load signal from LOW to HIGH. After the seed is loaded, wait for 1 clock cycle, then enable should be made HIGH. When enable is HIGH, the generator continuously produces pseudo-random sequences starting from the initial seed value (prbs_seed[14:0]). The output should remain stable between clock edges to allow proper sampling by the downstream serializer module.

PRBS15 polynomial: x^15 + x^14 + 1

LFSR Operation:
- The LFSR uses bits [14:0] (15 bits total)
- Feedback is computed as: feedback = bit[14] XOR bit[13]
- On each shift: lfsr[14:0] = {lfsr[13:0], feedback}
- Output bits are generated by reading bit[14] of the LFSR state 8 times, advancing the LFSR after each read
- If the loaded seed is 0, the output should remain 0 (zero seed produces zero output)

Partial RTL code
```
`timescale 1ns/1ps
module prbs_generator (input clock,//Positive edge-triggered clock
                       input reset_n,//Asynchronous active low reset
			           input enable, //When HIGH, prbs15 generation starts and when low prbs15 generation stops
                       input [14:0]prbs_seed, //Seed for PRBS15 (15-bit seed)
					   input load, //Loads the seed when transitioning from LOW to HIGH
			           output reg [7:0]prbs_out // PRBS output
			           );
	//Insert internal signal declarations
	
	//Implement PRBS15 generation logic:
	//1. Declare a 15-bit LFSR register (reg [14:0] lfsr)
	//2. Implement combinational logic to generate 8 output bits from the LFSR
	//3. Implement sequential logic to handle reset, load, and enable signals
	//4. When load transitions LOW to HIGH, load prbs_seed into the LFSR
	//5. When enable is HIGH, update the LFSR and output on each clock edge
	//6. When enable is LOW, keep the output stable (don't update prbs_out)
	//7. Handle zero seed case: if seed is 0, output should remain 0
	
endmodule
```